<?php
/**
 * COmanage Registry CO Rest DCC Provisioner Target Model
 *
 * Portions licensed to the University Corporation for Advanced Internet
 * Development, Inc. ("UCAID") under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * UCAID licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * @link          http://www.internet2.edu/comanage COmanage Project
 * @package       registry-plugin
 * @since         COmanage Registry v0.9.1
 * @license       Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

//App::uses('CakeSession', 'Model/Datasource');

App::uses("CoProvisionerPluginTarget", "Model");

// This file is generated by Composer
require_once APP . "AvailablePlugin" . DS . "RestDccProvisioner" . DS . "Vendor" . DS . "autoload.php";

class CoRestDccProvisionerTarget extends CoProvisionerPluginTarget {
  // Define class name for cake
  public $name = "CoRestDccProvisionerTarget";
  
  // Add behaviors
  public $actsAs = array('Containable');
  
  // Association rules from this model to other models
  public $belongsTo = array("CoProvisioningTarget");
  
  // Default display field for cake generated views
  public $displayField = "restdcc_url";
  
  // Validation rules for table elements
  public $validate = array(
    'co_provisioning_target_id' => array(
      'rule' => 'numeric',
      'required' => true,
      'message' => 'A CO Provisioning Target ID must be provided'
    ),
    'restdcc_url' => array(
      'rule' => 'notBlank'
    ),
    'client_id' => array(
      'rule' => 'notBlank'
    ),
    'client_secret' => array(
      'rule' => 'notBlank'
    ),
    'access_token' => array(
      'rule' => array('maxlength', 512)
    ),
    'refresh_token' => array(
      'rule' => array('maxlength', 512)
    ),
    'callback_url' => array(
      'rule' => array('maxlength', 512)
    )
  );
  
  /**
   * Establish a connection to the DCC RESTful API.
   *
   * @since  COmanage Registry v3.2.2
   * @param  String $restdcc_url Base URL of the DCC Server
   * @param  String $client_id OAuth2 Client ID
   * @param  String $client_id OAuth2 Client Secret
   * @param  String $callback_url OAuth2 Callback URL
   * @param  String $refresh_token DCC OAuth2 refresh token
   * @return Object Guzzle HTTP Client with Authorization header
   * @throws Exception
   */
  
  protected function ghConnect($target_data) {
    $restdcc_url = $target_data['restdcc_url'];
    $provider = new \League\OAuth2\Client\Provider\GenericProvider([
        'clientId'                => $target_data['client_id'],
        'clientSecret'            => $target_data['client_secret'],
        'redirectUri'             => $target_data['callback_url'],
        'urlAuthorize'            => $restdcc_url . '/oauth/oauth2/auth',
        'urlAccessToken'          => $restdcc_url . '/oauth/oauth2/token',
        'urlResourceOwnerDetails' => $restdcc_url . '/oauth/userinfo'
    ]);

    // refresh the access token
    $newAccessToken = $provider->getAccessToken('refresh_token', [
        'refresh_token' => $target_data['refresh_token']
    ]);

    $access_token = $newAccessToken->getToken();
    $refresh_token = $newAccessToken->getRefreshToken();

    if(!empty($access_token) && !empty($refresh_token)) {
      // save the updated tokens
      $target = new CoRestDccProvisionerTarget();
      $target->id = $target_data['id'];
      if($target->saveField('access_token', $access_token) &&
        $target->saveField('refresh_token', $refresh_token)) {

          $base_uri = $restdcc_url . '/rest-dcc/';
          $client = new GuzzleHttp\Client(['base_uri' => $base_uri,
                                           'timeout' => 5.0,
                                           'headers' => ['Authorization' => 'Bearer ' . $access_token] ]);
          return $client;

        } else {
          $this->Flash->set(_txt('er.db.save'), array('key' => 'error'));
        }
      } else {
        $this->Flash->set(_txt('er.restdccprovisioner.access_token'), array('key' => 'error'));
    }

    return null;
  }
  
  /**
   * Provision for the specified CO Person.
   *
   * @since  COmanage Registry v3.2.3
   * @param  Array CO Provisioning Target data
   * @param  ProvisioningActionEnum Registry transaction type triggering provisioning
   * @param  Array Provisioning data, populated with ['CoPerson'] or ['CoGroup']
   * @return Boolean True on success
   * @throws RuntimeException
   */
  
  public function provision($coProvisioningTargetData, $op, $provisioningData) {
    // If this is a person related operation, we need a dcc identifier to proceed.
    if(!empty($provisioningData['CoPerson']['id'])) {
      if(!empty($provisioningData['Identifier'])) {
        foreach($provisioningData['Identifier'] as $i) {
          if($i['type'] == 'DccDocDbID'
             && !empty($i['identifier'])
             && $i['status'] == StatusEnum::Active) {
            $dccid = $i['identifier'];
            break;
          }
        }
      }
    } else {
      // group operations do not need a DCC ID
      $dccid = null;
    }
    
    // What actions should we run?
    $syncGroupsForPerson = false;
    $syncMembersForGroup = false;
    
    switch($op) {
      case ProvisioningActionEnum::CoPersonAdded:
      case ProvisioningActionEnum::CoPersonPetitionProvisioned:
      case ProvisioningActionEnum::CoPersonPipelineProvisioned:
      case ProvisioningActionEnum::CoPersonReprovisionRequested:
      case ProvisioningActionEnum::CoPersonUnexpired:
      case ProvisioningActionEnum::CoPersonUpdated:
        $syncGroupsForPerson = true;
        break;
      case ProvisioningActionEnum::CoPersonDeleted:
        // We don't treat CoPersonDeleted specially, because the group membership should have been
        // deleted before the person. Note there is a bit of a race condition, in that if
        // the DCC identifier is deleted before the group membership, we won't be able
        // to deprovision. However, the CoGroupMember relationship is defined first in
        // Model/CoPerson.php, so this should happen in the correct order.
        break;
      case ProvisioningActionEnum::CoPersonExpired:
        // Delete group memberships, but not ssh keys
        $syncGroupsForPerson = true;
        break;
      case ProvisioningActionEnum::CoPersonEnteredGracePeriod:
        // We don't do anything on grace period
        break;
      case ProvisioningActionEnum::CoGroupAdded:
      case ProvisioningActionEnum::CoGroupUpdated:
      case ProvisioningActionEnum::CoGroupReprovisionRequested:
        // We'll sync the memberships on these actions, even though for added and
        // updated it usually isn't necessary.
        $syncMembersForGroup = true;
        break;
      case ProvisioningActionEnum::CoGroupDeleted:
        // As for CoPersonDeleted, there shouldn't really be anything to do here
        // since the memberships should already have been deleted.
        break;
      default:
        throw new RuntimeException("Not Implemented");
        break;
    }
    
    // Execute the actions identified, if configured
    
    if($syncGroupsForPerson) {
      $this->syncGroupsForCoPerson($coProvisioningTargetData['CoRestDccProvisionerTarget'],
                                   $provisioningData['CoPerson']['id'],
                                   $provisioningData['Co']['id'],
                                   $dccid,
                                   $provisioningData['CoGroupMember']);
    }
    
    if($syncMembersForGroup) {
      $this->syncMembersForCoGroup($coProvisioningTargetData['CoRestDccProvisionerTarget'],
                                   $provisioningData['CoGroup']['name'],
                                   $provisioningData['CoGroup']['id']);
    }
  
    return true;
  }
  
  /**
   * Synchronize DCC access controlls for a CO Group.
   *
   * @since  COmanage Registry v3.2.3
   * @param  String  $restdcc_url Base URL of the DCC Server
   * @param  String  $client_id OAuth2 Client ID
   * @param  String  $client_id OAuth2 Client Secret
   * @param  String  $callback_url OAuth2 Callback URL
   * @param  String  $refresh_token DCC OAuth2 refresh token
   * @param  String  $groupName     Group name
   * @param  String  $coGroupId     CO Group ID
   * @return Boolean true if groups are successfully synced
   * @throws Exception
   */
  
  protected function syncMembersForCoGroup($target_data, $groupName, $coGroupId) {
    error_log('syncMembersForCoGroup()');

    $client = $this->ghConnect($target_data);

    $response = $client->get('SecurityGroup');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );

    $response = $client->get('UsersGroup');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );
    
    return true;
  }
  
  /**
   * Synchronize DCC access controlls for a CO Person.
   *
   * @since  COmanage Registry v3.2.3
   * @param  String  $restdcc_url Base URL of the DCC Server
   * @param  String  $client_id OAuth2 Client ID
   * @param  String  $client_id OAuth2 Client Secret
   * @param  String  $callback_url OAuth2 Callback URL
   * @param  String  $refresh_token DCC OAuth2 refresh token
   * @param  String  $coPersonId   CO Person ID
   * @param  String  $coId         CO ID
   * @param  String  $dccid        DCC Unique ID for CO Person
   * @param  Array   $groupMembers  Current set of group memberships for COPerson
   * @return Boolean true if groups are successfully synced
   * @throws Exception
   */
  
  protected function syncGroupsForCoPerson($target_data, $coPersonId, $coId, $dccid, $groupMembers) {
    error_log('syncGroupsForCoPerson()');
    
    $client = $this->ghConnect($target_data);

    $response = $client->get('Author');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );

    $response = $client->get('RemoteUser');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );

    $response = $client->get('EmailUser');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );

    $response = $client->get('Institution');
    error_log( 'Got: ' . json_encode($response->getStatusCode()) );
    error_log( $response->getBody() );
    
    return true;
  }

}
